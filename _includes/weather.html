<html lang="">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <style>
        button div:hover {
            background-color: #d3d3d3;
        }
    </style>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" 
        href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" 
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" 
        crossorigin=""
    />
    <script 
        src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js" 
        integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==" 
        crossorigin=""
    ></script>
    <link rel="stylesheet" href="/css/leaflet-radar.css"/>
    <script src="/js/leaflet-radar.js"></script>
  </head>
  
  <body style='text-align:center'>
    <div id="search" style='margin-top:20px;display:flex;height:32px;align-items:center;justify-content:center;max-width:500px;margin:0 auto; margin-bottom:20px'>
        <button id='button1' onclick="getCurrentLocation()" class="fa fa-location-arrow fa-border" style="cursor:pointer;height:100%;"></button>
        <input id='textinput' type="text" style='height:100%;width:90%;'>
        <button id='button2' onclick="geocode()" class="fa fa-search fa-border" style="cursor:pointer;height:100%;"></button>
        <button id='button3' onclick="help()" class="fa fa-question fa-border" style="cursor:pointer;height:100%;"></button>
    </div>
    <div id="errors" style='text-align:center; max-width:1000px;margin:0 auto; margin-bottom:20px'></div>
    <div id="now" style='text-align:left; max-width:1000px;margin:0 auto;'></div>
    <div id="24h" style='text-align:center; max-width:1000px;margin:0 auto;'></div>
    <div id="map" style='text-align:center; max-width:1000px;margin:0 auto;'></div>
    <div id="days" style='text-align:center; max-width:700px;margin:0 auto;'></div>
    <div id="graphs" style='text-align:center; max-width:1000px;margin:0 auto;'></div>
    <script>
    
        //  Create text search box
        var loc = document.getElementById("textinput")
        loc.setAttribute("value", "Atlanta, GA");
        
        //  Allow pressing enter to submit
        loc.addEventListener("keyup", function(event) {
            if (event.keyCode === 13) {
                event.preventDefault();
                document.getElementById("button2").click();
            }
        })
        
        //  get request version 1
        var HttpClient1 = function() {
            this.get = function(aUrl, aCallback) {
                var anHttpRequest = new XMLHttpRequest();
                anHttpRequest.onreadystatechange = function() { 
                    if (anHttpRequest.readyState == 4 && anHttpRequest.status == 200) {
                        aCallback(anHttpRequest.responseText); 
                    }
                }
                anHttpRequest.open( "GET", aUrl, true );            
                anHttpRequest.send( null );
            }
        }
        
        //  Get request version 2
        var HttpClient2 = function() {
            this.get = function(aUrl, aCallback) {
                var anHttpRequest = new XMLHttpRequest();
                anHttpRequest.onreadystatechange = function() { 
                    if (anHttpRequest.readyState == 4) {
                        if (anHttpRequest.status == 200 || anHttpRequest.status == 304) {
                            aCallback(anHttpRequest.responseText); 
                        }
                        else {
                            aCallback(null); 
                        }
                    }
                }
                anHttpRequest.open( "GET", aUrl, true );            
                anHttpRequest.send( null );
            }
        }
        
        //  Get current location and run weather
        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    getWeather(position.coords.latitude, position.coords.longitude, true)
                });
            }
        }
        
        //  Clear all child divs of an id
        function clearID(id) {
            var node = document.getElementById(id)
            if (node !== null) {
                while (node.hasChildNodes()) {
                    node.removeChild(node.lastChild);
                }
            }
        }
        
        //  Convert Celcius to Fahrenheit
        function c2f(celcius) {
            return celcius * 9.0 / 5.0 + 32.0
        }
        
        const dayFind = /(\d+)D/
        const hourFind = /(\d+)H/
        function parseDuration(string) {
            var hourOffset = 0
            if (string.includes('D'))
                hourOffset += parseInt(string.match(dayFind)[1]) * 24
            if (string.includes('H'))
                hourOffset += parseInt(string.match(hourFind)[1])
            return hourOffset
        }
        
        
        //  Get weather data
        function getWeather(lat, lon, reverseGeo=false) {
        
            if (reverseGeo)
                reverseGeocode(lat,lon)
            
            var locString = lat + ',' + lon
            var client = new HttpClient2();
            client.get('https://api.weather.gov/points/' + locString, function(pointsResponse) {
                responseJson = JSON.parse(pointsResponse)
                degreeSymbol = String.fromCharCode(176)
                //  clear any existing errors
                clearID('errors')
                
                //  Print error if weather not found
                if (responseJson == null || responseJson.length == 0) {
                    printError('Error: Weather at this location is not available from Weather.gov.')
                }
                else {
                    clearID('errors')
                    responseJson = JSON.parse(pointsResponse)
                    console.log("point:")
                    console.log(responseJson)
                    forcastDay = responseJson.properties.forecast
                    forcastGrid = responseJson.properties.forecastGridData
                    
                    //  Create detailed forecasts
                    client.get(forcastGrid, function(gridResponse) {
                        responseJson = JSON.parse(gridResponse)
                        
                        //  Print error if data not available
                        if (responseJson == null || responseJson.length == 0) {
                            printError('Error: Weather at this location is not available from Weather.gov.')
                        }
                        props = responseJson.properties
                        console.log("griddata:")
                        console.log(props)
                        timeLength = props.temperature.values.length
                        
                        //  Plot map
                        clearID('map')
                        var div = document.createElement('div');
                        div.style.width = "100%";
                        div.style.height = "450px";
                        div.style.display = "inline-block";
                        div.id = 'map1'
                        elem = document.getElementById("map").appendChild(div)

                        var map = L.map("map1",{doubleClickZoom:false}).setView([lat,lon], 6);
                        var osmAttribution ='Map data &copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors';
                        var leafletRadarAttribution ='<a href="https://github.com/rwev/leaflet-radar">Radar</a>';
                        L.tileLayer(
                                "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                                {attribution: [osmAttribution,leafletRadarAttribution].join(" | ")}
                        ).addTo(map);
                        L.marker([lat,lon]).addTo(map);
                        L.control.radar({}).addTo(map);
                        map.on('dblclick', function(e) {
                            getWeather(e.latlng.lat, e.latlng.lng, true)
                        });
                        
                        
                        //  Create day by day summary
                        client.get(forcastDay, function(forecastResponse) {
                            dayProps = JSON.parse(forecastResponse).properties
                            console.log("daydata:")
                            console.log(dayProps)
                            
                            //  Print text summary of present forecast
                            clearID('now')
                            nowDiv = document.getElementById('now')
                            nowDiv.style.display = 'flex'
                            var middleColumn = document.createElement("div");
                            middleColumn.style.width='100%'                            
                            var p1 = document.createElement("p");
                            var bold = document.createElement("b");
                            var prefix = document.createTextNode(dayProps.periods[0].name + ': ')
                            var summary = document.createTextNode(dayProps.periods[0].detailedForecast);
                            bold.appendChild(prefix)
                            p1.appendChild(bold)
                            p1.appendChild(summary)
                            middleColumn.appendChild(p1)
                            nowDiv.appendChild(middleColumn)
                            
                            //  Match min temperature to max temperature
                            numBars = Math.min(props.maxTemperature.values.length, props.minTemperature.values.length)
                            if (props.minTemperature.values.length !== props.maxTemperature.values.length) {
                                firstDateMin = new Date(props.minTemperature.values[0].validTime.split('/')[0])
                                firstDateMax = new Date(props.maxTemperature.values[0].validTime.split('/')[0])
                                if (firstDateMin.getDate() == firstDateMax.getDate()) {
                                    props.minTemperature.values = props.minTemperature.values.slice(0,numBars)
                                    props.maxTemperature.values = props.maxTemperature.values.slice(0,numBars)
                                }
                                else {
                                    props.minTemperature.values = props.minTemperature.values.slice(props.minTemperature.values.length - numbars)
                                    props.maxTemperature.values = props.minTemperature.values.slice(props.maxTemperature.values.length - numbars)
                                }
                            }
                            
                            //  Convert celcius to farenheit
                            if (props.minTemperature.uom.includes('degC')) {
                                for (var i = 0; i < numBars; i++) {
                                    props.minTemperature.values[i].value = c2f(props.minTemperature.values[i].value)
                                    props.maxTemperature.values[i].value = c2f(props.maxTemperature.values[i].value)
                                }
                            }
                           
                            //   Find common min and max for all bar charts
                            var minT = props.minTemperature.values[0].value
                            var maxT = props.maxTemperature.values[0].value
                            for (var i = 1; i < numBars; i++) {
                                if (props.minTemperature.values[i].value < minT)
                                    minT = props.minTemperature.values[i].value
                                if (props.maxTemperature.values[i].value > maxT)
                                    maxT = props.maxTemperature.values[i].value
                            }
                            
                            //  Clear div before populating
                            clearID('days')
                            for (var i = 0; i < numBars; i++) {
                            
                                validDay = props.minTemperature.values[i].validTime.split('T')[0]
                                
                                trace1 = {
                                    x: [props.minTemperature.values[i].value],
                                    y: [validDay],
                                    type: 'bar',
                                    orientation: 'h',
                                    marker: {
                                        color: 'rgba(1,1,1,0.0)'
                                    },
                                    text: Math.round(props.minTemperature.values[i].value).toString() + degreeSymbol,
                                    textposition: 'outside',
                                }
                                
                                trace2 = {
                                    x:  [props.maxTemperature.values[i].value-props.minTemperature.values[i].value],
                                    y: [validDay],
                                    type: 'bar',
                                    marker: {
                                        color: '#737373'
                                    },
                                    orientation: 'h',
                                    text: Math.round(props.maxTemperature.values[i].value).toString() + degreeSymbol,
                                    textposition: 'outside',
                                }
                                
                                var layout = {
                                    paper_bgcolor:'rgba(0,0,0,0)',
                                    plot_bgcolor:'rgba(0,0,0,0)',
                                    showlegend: false,
                                    margin: {b:3, t:3,l:40,r:0},
                                    height: 35,
                                    xaxis: {
                                        showgrid: false,
                                        showline: false,
                                        zeroline: false,
                                        fixedrange: true,
                                        showticklabels: false,
                                        range: [minT-3, maxT+3],
                                    },
                                    yaxis: {
                                        showline: false,
                                        showgrid: false,
                                        zeroline: false,
                                        autotick:false,
                                        tickformat: '<b>%a</b>',
                                        fixedrange: true,
                                    },
                                    barmode: 'stack',
                                }
                                
                                var config = {
                                    responsive: true,
                                    displayModeBar: false,
                                    staticPlot: true,
                                }
                                
                                if (i == 0) {
                                    if ((new Date(validDay)).getUTCDate() == new Date().getDate()) {
                                        trace1.y = ['<b>Today</b>']
                                        trace2.y = ['<b>Today</b>']
                                    }
                                }
                                
                                var div = document.createElement('button');
                                div.style.outline = 'none'
                                div.style['background-color'] = 'Transparent'
                                div.style.cursor = 'Pointer'
                                div.style.border='none'
                                div.style.width = "100%";
                                div.style.display = "inline-block";
                                elem = document.getElementById("days").appendChild(div)
                                elem.classList.add('collapsible')
                                
                                var content = document.createElement('div')
                                
                                
                                var div = document.createElement('div');
                                div.style.width = "100%";
                                div.style.display = "inline-block";
                                div.class = 'collapsible'
                                div.type = 'button'
                                elem = elem.appendChild(div)
                                Plotly.newPlot(elem, [trace1,trace2], layout, config);
                            }
                        })
                        
                        //  Generate data arrays
                        fields = ['temperature','probabilityOfPrecipitation', 'quantitativePrecipitation', 'dewpoint','relativeHumidity']
                        dataStruct = {}
                        fields.forEach(function (field, index) {
                            if (field in props) {
                                numPoints = props[field].values.length
                                entryStruct = {'time':new Array(), 'data':new Array(), 'unit':''}
                                
                                //  Extract parameter unit
                                if ('uom' in props[field])
                                    entryStruct.unit = props[field].uom.split(':')[1]
                                    
                                //  Get date of today, and date in 24 hours
                                today = new Date()
                                today.setHours(today.getHours()-1)
                                todayPlus24h = new Date()
                                todayPlus24h.setDate(todayPlus24h.getDate() + 1)
                                
                                //  Create array of data
                                for (var i = 0; i < numPoints; i++) {
                                    iso8601String = props[field].values[i].validTime
                                    
                                    isoSplit = iso8601String.split('/')
                                    startTime = new Date(isoSplit[0])
                                    duration = parseDuration(isoSplit[1])
                                    
                                    //  Only plot next 24 hours
                                    if (startTime >= today && startTime < todayPlus24h) {
                                        //  Repeat value for specified number of hours
                                        for (var h = 0; h < duration; h++) {
                                            currentTime = new Date(startTime)
                                            currentTime.setHours(currentTime.getHours() + h)
                                            if (currentTime <= todayPlus24h) {
                                                entryStruct.time.push(currentTime)
                                                entryStruct.data.push(props[field].values[i].value)
                                            }
                                        }
                                    }
                                }
                                if (entryStruct.unit.includes('degC')) {
                                    for (var i = 0; i < entryStruct.data.length; i++) {
                                        entryStruct.data[i] = c2f(entryStruct.data[i])
                                    }
                                    entryStruct.unit = degreeSymbol + 'F'
                                }
                                else if (entryStruct.unit.includes('degF'))
                                    entryStruct.unit = degreeSymbol + 'F'
                                if (entryStruct.unit == 'mm') {
                                    for (var i = 0; i < entryStruct.data.length; i++) {
                                        entryStruct.data[i] = entryStruct.data[i] / 25.4
                                    }
                                    entryStruct.unit = 'in'
                                }
                                dataStruct[field] = entryStruct
                            }
                            else {
                                console.log('Error: ' + field + ' not in properties')
                            }
                            
                        })
                        
                        //  Generate plots
                        clearID('graphs')
                        gridcolor = '#000'
                        for (var key of Object.keys(dataStruct)) {
                            // Add plot div
                            var div = document.createElement(key);
                            div.style.width = "100%";
                            div.style.display = "inline-block";
                            elem = document.getElementById("graphs").appendChild(div)
                            title = key
                            if (dataStruct[key].unit != '')
                                title += ' (' + dataStruct[key].unit + ')'
                            var layout = {
                                paper_bgcolor:'rgba(0,0,0,0)',
                                plot_bgcolor:'rgba(0,0,0,0)',
                                title: title,
                                xaxis: {
                                    type:'date',
                                    tickformat: '%b %-d, %-I %p',
                                    //gridcolor: gridcolor,
                                    fixedrange: true,
                                },
                                yaxis: {
                                    //gridcolor: gridcolor,
                                    fixedrange: true,
                                },

                            }
                            var config = {
                                responsive: true,
                                displayModeBar: false,
                            }
                            var trace1 = {
                                x: dataStruct[key].time,
                                y: dataStruct[key].data,
                                mode:'lines',
                                type:'scatter',
                                line: {
                                    color: '#000',
                                    width: 3,
                                },
                            }
                            if (dataStruct[key].unit == 'percent') {
                                layout.yaxis.range = [0, 100]
                            }
                            Plotly.newPlot(elem, [trace1], layout, config)
                        }
                    })
                }
                
            })
        }
        
        //  Prints specified error
        function printError(message) {
            var node = document.createTextNode(message)
            document.getElementById("errors").appendChild(node)
        }
        
        // Get coordinate of location
        function geocode() {
            var client = new HttpClient1();
            url = 'https://nominatim.openstreetmap.org/search?q=' + loc.value + '&format=json&limit=1'
            client.get(url, function(nomResponse) {
                responseJson = JSON.parse(nomResponse)
                clearID('errors')
                if (responseJson.length == 0) {
                    printError('Error: Location not identifiable from \"' + loc.value + '\".  Try again.')
                }
                else {
                    var lat = responseJson[0].lat
                    var lon = responseJson[0].lon
                    console.log('Geocode success: ' + loc.value + ' -> (' + lat + ', ' + lon + ')' )
                    getWeather(lat,lon)
                    
                }
            })
        }
        
        function reverseGeocode(lat,lon) {
            var client = new HttpClient1();
            url = 'https://nominatim.openstreetmap.org/reverse?lat=' + lat + '&lon=' + lon + '&format=json'
            client.get(url, function(nomResponse) {
                responseJson = JSON.parse(nomResponse)
                clearID('errors')
                if (responseJson.length == 0) {
                    printError('Error: Reverse geocoding failed.  Input: lat=' + lat + ', lon=' + lon)
                }
                else {
                    document.getElementById("textinput").setAttribute("value", responseJson.display_name);
                }
            })
        }
        var showhelp = true
        function help() {
            clearID('errors')
            if (showhelp == true) {
                printError('Enter a location by using your current location, the text search box, or double-click on map.')
                showhelp = false
            }
            else
                showhelp = true
        }
        
        geocode()
    </script>
  </body>
</html>
