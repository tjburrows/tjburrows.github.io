<html lang="">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <style>
        button div:hover {
            background-color: #d3d3d3;
        }
    </style>
    
    <!-- plotly -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <!-- font awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
    <!-- leaflet -->
    <link rel="stylesheet" 
        href="https://unpkg.com/leaflet@latest/dist/leaflet.css" 
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" 
        crossorigin=""
    />
    <script 
        src="https://unpkg.com/leaflet@latest/dist/leaflet.js" 
        integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==" 
        crossorigin=""
    ></script>
    
    <!-- leaflet-radar -->
    <link rel="stylesheet" href="/css/leaflet-radar.css"/>
    <script src="/js/leaflet-radar.js"></script>
  </head>
  
  <body style='text-align:center'>
    <div id="search" style='margin-top:20px;display:flex;height:32px;align-items:center;justify-content:center;max-width:500px;margin:0 auto; margin-bottom:20px'>
        <button id='button1' onclick="getCurrentLocation()" class="fa fa-location-arrow fa-border" style="cursor:pointer;height:100%;"></button>
        <input id='textinput' type="text" style='height:100%;width:90%;'>
        <button id='button2' onclick="geocode()" class="fa fa-search fa-border" style="cursor:pointer;height:100%;"></button>
        <button id='button3' onclick="help()" class="fa fa-question fa-border" style="cursor:pointer;height:100%;"></button>
    </div>
    <div id="errors" style='text-align:center; max-width:1000px;margin:0 auto; margin-bottom:20px'></div>
    <div id="now" style='text-align:left; max-width:1000px;margin:0 auto;'>
        <div id="conditions"></div>
        <div id="summary"></div>
    </div>
    <div id="map" style='text-align:center; max-width:1000px;margin:0 auto;'>
        <div id="map1" style='width:100%; height:350px; display:inline-block'></div>
    </div>
    
    <div id="days" style='text-align:center; max-width:700px;margin:0 auto;'></div>
    <div id="graphs" style='text-align:center; max-width:1000px;margin:0 auto;'></div>
    <script>
        //  Create text search box
        var loc = document.getElementById("textinput")
        mapDrawn = false
        loc.setAttribute("value", "Atlanta, GA");
        
        //  Allow pressing enter to submit
        loc.addEventListener("keyup", function(event) {
            if (event.keyCode === 13) {
                event.preventDefault();
                document.getElementById("button2").click();
            }
        })
        
        //  Get current location and run weather
        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    getWeather(position.coords.latitude, position.coords.longitude, true)
                });
            }
        }
        
        //  Clear all child divs of an id
        function clearID(id) {
            var node = document.getElementById(id)
            if (node !== null) {
                while (node.hasChildNodes()) {
                    node.removeChild(node.lastChild);
                }
            }
        }
        
        function fetch_retry(url, options = {}, retries = 3) {
            const retryCodes = [408, 500, 502, 503, 504, 522, 524]
            return fetch(url, options)
            .then(res => {
                if (res.ok) 
                    return res
                if (retries > 0 && retryCodes.includes(res.status)) {
                    return fetch_retry(url, options, retries - 1)
                } else {
                    throw new Error(res)
                }
            })
            .catch(console.error)
        }
        
        //  Convert Celcius to Fahrenheit
        function c2f(celcius) {
            return celcius * 9.0 / 5.0 + 32.0
        }
        
        //  Convert meters to feet
        function m2ft(meters) {
            return (meters * 100) / (12 * 2.54)
        }
        
        const dayFind = /(\d+)D/
        const hourFind = /(\d+)H/
        function parseDuration(string) {
            var hourOffset = 0
            if (string.includes('D'))
                hourOffset += parseInt(string.match(dayFind)[1]) * 24
            if (string.includes('H'))
                hourOffset += parseInt(string.match(hourFind)[1])
            return hourOffset
        }
        
        function generateDataOnDate(gridProps, fields, date) {
            dataStruct = {}
            fields.forEach(function (field, index) {
                if (field in gridProps) {
                    numPoints = gridProps[field].values.length
                    entryStruct = {'time':new Array(), 'data':new Array(), 'unit':''}
                    
                    //  Extract parameter unit
                    if ('uom' in gridProps[field])
                        entryStruct.unit = gridProps[field].uom.split(':')[1]
                        
                    //  Get date of today, and date in 24 hours
                    datePlus24h = new Date(date)
                    datePlus24h.setDate(datePlus24h.getDate() + 1)
                    
                    //  Create array of data
                    for (var i = 0; i < numPoints; i++) {
                        iso8601String = gridProps[field].values[i].validTime
                        
                        isoSplit = iso8601String.split('/')
                        startTime = new Date(isoSplit[0])
                        duration = parseDuration(isoSplit[1])
                        
                        //  Only plot next 24 hours
                        if (startTime >= date && startTime < datePlus24h) {
                            //  Repeat value for specified number of hours
                            for (var h = 0; h < duration; h++) {
                                currentTime = new Date(startTime)
                                currentTime.setHours(currentTime.getHours() + h)
                                if (currentTime <= datePlus24h) {
                                    entryStruct.time.push(currentTime)
                                    entryStruct.data.push(gridProps[field].values[i].value)
                                }
                            }
                        }
                    }
                    if (entryStruct.unit.includes('degC')) {
                        for (var i = 0; i < entryStruct.data.length; i++) {
                            entryStruct.data[i] = c2f(entryStruct.data[i])
                        }
                        entryStruct.unit = degreeSymbol + 'F'
                    }
                    else if (entryStruct.unit.includes('degF'))
                        entryStruct.unit = degreeSymbol + 'F'
                    if (entryStruct.unit == 'mm') {
                        for (var i = 0; i < entryStruct.data.length; i++) {
                            entryStruct.data[i] = entryStruct.data[i] / 25.4
                        }
                        entryStruct.unit = 'in'
                    }
                    dataStruct[field] = entryStruct
                }
                else {
                    console.log('Error: ' + field + ' not in properties')
                }
            })
            return dataStruct
        }
        
        //  Get weather data
        var degreeSymbol = String.fromCharCode(176)
        function getWeather(lat, lon, reverseGeo=false) {
        
            if (reverseGeo) {
                reverseGeocode(lat,lon)
            }
                
            
            clearID('days')
            clearID('graphs')
            clearID('errors')
            clearID('summary')
            clearID('conditions')
            
            //  Create map
            if (!mapDrawn) {
                mapDrawn = true
                map = L.map("map1",{doubleClickZoom:false, scrollWheelZoom:false}).setView([lat,lon], 6);
                osmAttribution ='Map data &copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors';
                leafletRadarAttribution ='<a href="https://github.com/rwev/leaflet-radar">Radar</a>';
                L.tileLayer(
                        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                        {attribution: [osmAttribution, leafletRadarAttribution].join(" | ")}
                ).addTo(map);
                marker = L.marker([lat,lon]).addTo(map);
                L.control.radar({}).addTo(map);
                map.on('dblclick', function(e) {
                getWeather(e.latlng.lat, e.latlng.lng, true)
                }).on('contextmenu', function(e) {
                    getWeather(e.latlng.lat, e.latlng.lng, true)
                })
            }
            else {
                map.panTo([lat,lon]);
                map.removeLayer(marker)
                marker = L.marker([lat,lon]).addTo(map);
            }
            
            fetch_retry('https://api.weather.gov/points/' + lat + ',' + lon, {method:'GET'}, 5)
            .then(function(response) { return response.json() })
            .then(function(pointsJson) { 
                if (pointsJson == null || pointsJson.length == 0) {
                    printError('Error: Weather at this location is not available from Weather.gov.')
                }
                else {
                    console.log("point:", pointsJson)
                    return pointsJson;
                }
            })
            .then(function(pointsJson) {
                clearID('conditions')
                fetch_retry(pointsJson.properties.observationStations, {method:'GET'}, 5)
                .then(function(response) { return response.json(); })
                .then(function(json) {
                    var station = json.features[0]
                    console.log('station:', station)
                    var elevation = station.properties.elevation.value
                    if (station.properties.elevation.unitCode.includes('unit:m'))
                        elevation = m2ft(elevation)
                    var stationID = station.properties.stationIdentifier
                    fetch_retry('https://api.weather.gov/stations/' + stationID + '/observations/latest?require_qc=true', {method:'GET'}, 5)
                    .then(function(response) {return response.json()})
                    .then(function(json) {
                        console.log('observation:', json)
                        currentTemp = json.properties.temperature.value
                        if (json.properties.temperature.unitCode.includes('degC')) {
                            currentTemp = Math.round(c2f(currentTemp))
                            json.properties.temperature.unitCode.includes = 'degF'
                        }
                        else {
                            currentTemp = Math.round(currentTemp)
                        }
                        nowDiv = document.getElementById('conditions')
                        nowDiv.style['text-align'] = 'center'
                        var currentConditions = document.createElement("h3");
                        currentConditions.style['margin-top'] = '0px'                            
//                             var p1 = document.createElement("strong");
                        var temp = document.createTextNode(currentTemp.toString() + degreeSymbol + ' ' + json.properties.textDescription);
                        currentConditions.appendChild(temp)
                        nowDiv.appendChild(currentConditions)
                    })
                })
                
                //  Create day by day summary
                fetch_retry(pointsJson.properties.forecast, {method:'GET'}, 5)
                .then(function(response) { return response.json(); })
                .then(function(json) {
                    dayProps = json.properties
                    console.log("daydata:", dayProps)
                    
                    //  Print text summary of present forecast
                    nowDiv = document.createElement("div")
                    nowDiv.style['text-align'] = 'left'
                    nowDiv.style.display = 'flex'
                    var middleColumn = document.createElement("div");
                    middleColumn.style.width='100%'                            
                    var p1 = document.createElement("p");
                    var bold = document.createElement("b");
                    var prefix = document.createTextNode(dayProps.periods[0].name + ': ')
                    var summary = document.createTextNode(dayProps.periods[0].detailedForecast);
                    bold.appendChild(prefix)
                    p1.appendChild(bold)
                    p1.appendChild(summary)
                    middleColumn.appendChild(p1)
                    nowDiv.appendChild(middleColumn)
                    document.getElementById('summary').appendChild(nowDiv)
                })
                
                //  Create detailed forecasts
                fetch_retry(pointsJson.properties.forecastGridData, {method:'GET'}, 5)
                .then(function(response) { 
                    return response.json()})
                .then(function(gridJson) { 
                    if (gridJson == null || gridJson.length == 0 || gridJson.properties == undefined) {
                        printError('Error: Weather at this location is not available from Weather.gov.')
                    }
                    else {
                        console.log("griddata:", gridJson)
                        return gridJson
                    }
                })
                .then(function(gridJson) {                        
                    gridProps = gridJson.properties
                    timeLength = gridProps.temperature.values.length
                    
                    //  Match min temperature to max temperature
                    var minDate0 = gridProps.minTemperature.values[0].validTime.split('T')[0]
                    var maxDate0 = gridProps.maxTemperature.values[0].validTime.split('T')[0]
                    if (minDate0 != maxDate0) {
                        if (minDate0 < maxDate0)
                            gridProps.minTemperature.values = gridProps.minTemperature.values.slice(1)
                        else
                            gridProps.maxTemperature.values = gridProps.maxTemperature.values.slice(1)
                    }
                    var minDateEnd = gridProps.minTemperature.values.slice(-1)[0].validTime.split('T')[0]
                    var maxDateEnd = gridProps.maxTemperature.values.slice(-1)[0].validTime.split('T')[0]
                    if (minDateEnd != maxDateEnd) {
                        if (minDateEnd > maxDateEnd)
                            gridProps.minTemperature.values = gridProps.minTemperature.values.slice(0,-1)
                        else
                            gridProps.maxTemperature.values = gridProps.maxTemperature.values.slice(0,-1)
                    }
                    
                    numBars = gridProps.minTemperature.values.length
                    
                    //  Convert celcius to farenheit
                    if (gridProps.minTemperature.uom.includes('degC')) {
                        for (var i = 0; i < numBars; i++) {
                            gridProps.minTemperature.values[i].value = c2f(gridProps.minTemperature.values[i].value)
                            gridProps.maxTemperature.values[i].value = c2f(gridProps.maxTemperature.values[i].value)
                        }
                        gridProps.minTemperature.uom = 'degF'
                        gridProps.maxTemperature.uom = 'degF'
                    }
                    
                    //   Find common min and max for all bar charts
                    var minT = gridProps.minTemperature.values[0].value
                    var maxT = gridProps.maxTemperature.values[0].value
                    for (var i = 1; i < numBars; i++) {
                        if (gridProps.minTemperature.values[i].value < minT)
                            minT = gridProps.minTemperature.values[i].value
                        if (gridProps.maxTemperature.values[i].value > maxT)
                            maxT = gridProps.maxTemperature.values[i].value
                    }
                    
                    //  Generate data arrays
                    fields = ['temperature','probabilityOfPrecipitation', 'quantitativePrecipitation', 'dewpoint','relativeHumidity']
                    dataStruct = generateDataOnDate(gridProps, fields, new Date())
                    validDay = []
                    for (var i = 0; i < numBars; i++) {
                        
                        validDay[i] = gridProps.minTemperature.values[i].validTime.split('T')[0]
                        
                        trace1 = {
                            x: [gridProps.minTemperature.values[i].value],
                            y: [validDay[i]],
                            type: 'bar',
                            orientation: 'h',
                            marker: {
                                color: 'rgba(1,1,1,0.0)'
                            },
                            text: Math.round(gridProps.minTemperature.values[i].value).toString() + degreeSymbol,
                            textposition: 'outside',
                        }
                        
                        trace2 = {
                            x:  [gridProps.maxTemperature.values[i].value-gridProps.minTemperature.values[i].value],
                            y: [validDay[i]],
                            type: 'bar',
                            marker: {
                                color: '#737373'
                            },
                            orientation: 'h',
                            text: Math.round(gridProps.maxTemperature.values[i].value).toString() + degreeSymbol,
                            textposition: 'outside',
                        }
                        
                        var layout = {
                            paper_bgcolor:'rgba(0,0,0,0)',
                            plot_bgcolor:'rgba(0,0,0,0)',
                            showlegend: false,
                            margin: {b:3, t:3,l:40,r:0},
                            height: 35,
                            xaxis: {
                                showgrid: false,
                                showline: false,
                                zeroline: false,
                                fixedrange: true,
                                showticklabels: false,
                                range: [minT-3, maxT+3],
                            },
                            yaxis: {
                                showline: false,
                                showgrid: false,
                                zeroline: false,
                                autotick:false,
                                tickformat: '<b>%a</b>',
                                fixedrange: true,
                            },
                            barmode: 'stack',
                        }
                        
                        var config = {
                            responsive: true,
                            displayModeBar: false,
                            staticPlot: true,
                        }
                        
                        if (i == 0) {
                            if ((new Date(validDay[i])).getUTCDate() == new Date().getDate()) {
                                trace1.y = ['<b>Today</b>']
                                trace2.y = ['<b>Today</b>']
                            }
                        }
                        
                        var div = document.createElement('button');
                        div.style.outline = 'none'
                        div.style['background-color'] = 'Transparent'
                        div.style.cursor = 'Pointer'
                        div.style.border='none'
                        div.style.width = "100%";
                        div.style.display = "inline-block";
                        elem = document.getElementById("days").appendChild(div)
                        elem.classList.add('collapsible')
                        
                        elem.onclick =  function(i) {
                            return function() {
                            this.classList.toggle("active");                            
                            var content = this.nextElementSibling
                            if (content.style.display === "block") {
                                content.style.display = "none";
                            } 
                            else {
                                content.style.display = "block";
                                if (!content.classList.contains('generated')) {
                                    content.classList.add("generated")
                                    
                                    fields = ['temperature', 'apparentTemperature']
                                    var localMidnight = new Date(validDay[i])
                                    localMidnight.setMinutes(localMidnight.getMinutes() + localMidnight.getTimezoneOffset())
                                    var tempData = generateDataOnDate(gridProps, fields, localMidnight)
                                   
                                    var div = document.createElement('div')
                                    div.style.width = "100%"
                                    div.style.display = "inline-block"
                                    elem = content.appendChild(div)

                                    var layout = {
                                        height: 200,
                                        paper_bgcolor:'rgba(0,0,0,0)',
                                        plot_bgcolor:'rgba(0,0,0,0)',
                                        title: 'Temperature (' + degreeSymbol + 'F)',
                                        xaxis: {
                                            type:'date',
                                            tickformat: '%-I %p',
                                            fixedrange: true,
                                        },
                                        yaxis: {
                                            fixedrange: true,
                                        },
                                        legend: {
                                            traceorder: 'reversed',
                                        },
                                        margin: {b:30, t:40,l:30,r:0},
                                    }

                                    var config = {
                                        responsive: true,
                                        displayModeBar: false,
                                    }
                                    var traces = []
                                    traces[1] = {
                                        x: tempData['temperature'].time,
                                        y: tempData['temperature'].data,
                                        mode:'lines',
                                        type:'scatter',
                                        line: {
                                            color: '#000',
                                            width: 3,
                                        },
                                        name: 'Actual',
                                    }
                                    traces[0] = {
                                        x: tempData['apparentTemperature'].time,
                                        y: tempData['apparentTemperature'].data,
                                        mode:'lines',
                                        type:'scatter',
                                        line: {
                                            color: '#888',
                                            width: 3,
                                        },
                                        name: 'Feels Like',
                                    }
                                    Plotly.newPlot(elem, traces, layout, config)
                                }
                                
                            }
                        }}(i)
                        
                        var div = document.createElement('div');
                        div.style.width = "100%";
                        div.style.display = "inline-block";
                        div.type = 'button'
                        elem = elem.appendChild(div)
                        Plotly.newPlot(elem, [trace1,trace2], layout, config);
                        
                        
                        // create content of collapsible
                        var content = document.createElement('h1')
                        content.classList.add('content')
                        content.style.display = 'none'
                        content.style.width = '100%'
                        content.style.height = 200
                        content.style['margin-bottom'] = 0
                        content.style.overflow = 'hidden'
                        document.getElementById("days").appendChild(content)
                        
                        
                    }
                    
                    //  Generate plots
//                     clearID('graphs')
//                     gridcolor = '#000'
//                     for (var key of Object.keys(dataStruct)) {
//                         var div = document.createElement(key);
//                         div.style.width = "100%";
//                         div.style.display = "inline-block";
//                         elem = document.getElementById("graphs").appendChild(div)
//                         title = key
//                         if (dataStruct[key].unit != '')
//                             title += ' (' + dataStruct[key].unit + ')'
//                         var layout = {
//                             paper_bgcolor:'rgba(0,0,0,0)',
//                             plot_bgcolor:'rgba(0,0,0,0)',
//                             title: title,
//                             xaxis: {
//                                 type:'date',
//                                 tickformat: '%b %-d, %-I %p',
//                                 fixedrange: true,
//                             },
//                             yaxis: {
//                                 fixedrange: true,
//                             },
// 
//                         }
//                         var config = {
//                             responsive: true,
//                             displayModeBar: false,
//                         }
//                         var trace1 = {
//                             x: dataStruct[key].time,
//                             y: dataStruct[key].data,
//                             mode:'lines',
//                             type:'scatter',
//                             line: {
//                                 color: '#000',
//                                 width: 3,
//                             },
//                         }
//                         if (dataStruct[key].unit == 'percent') {
//                             layout.yaxis.range = [0, 100]
//                         }
//                         Plotly.newPlot(elem, [trace1], layout, config)
//                     }
                })
            })
        }
        
        //  Prints specified error
        function printError(message) {
            var node = document.createTextNode(message)
            document.getElementById("errors").appendChild(node)
        }
        
        // Get coordinate of location
        function geocode() {
            url = 'https://nominatim.openstreetmap.org/search?q=' + loc.value + '&format=json&limit=1'
            fetch_retry(url, {method:'GET'}, 5)
            .then(function(response) { return response.json(); })
            .then(function(nomJson) {
                if (nomJson.length == 0) {
                    printError('Error: Location not identifiable from \"' + loc.value + '\".  Try again.')
                }
                else {
                    var lat = nomJson[0].lat
                    var lon = nomJson[0].lon
                    console.log('Geocode success: ' + loc.value + ' -> (' + lat + ', ' + lon + ')' )
                    getWeather(lat,lon)
                    
                }
            })
        }
        
        function getCurrentValue(array) {
            var now = new Date()
            var iTime = 0
            for (i = 0; i < array.length; i++) {
                iTime = new Date(array[i].validTime.split('/')[0])
                if (iTime > now)
                    return array[i-1].value
            }
        }
        
        function reverseGeocode(lat,lon) {
            url = 'https://nominatim.openstreetmap.org/reverse?lat=' + lat + '&lon=' + lon + '&format=json&zoom=14'
            fetch_retry(url, {method:'GET'}, 5)
            .then(function(response) { return response.json(); })
            .then(function(reverseJson) {
                clearID('errors')
                if (reverseJson.length == 0) {
                    printError('Error: Reverse geocoding failed.  Input: lat=' + lat + ', lon=' + lon)
                }
                else {
                    document.getElementById("textinput").value = reverseJson.display_name.slice(0, -(reverseJson.address.country.length + 2));
                }
            })
        }
        
        var showhelp = true
        function help() {
            clearID('errors')
            if (showhelp == true) {
                printError('Enter a location by using your current location, the text search box, or the map by double-click, right click, or long press (mobile).')
                showhelp = false
            }
            else
                showhelp = true
        }
        
        function eucDist(coord1,coord2) {
            return Math.sqrt(Math.pow(coord1[0] - coord2[0], 2) + Math.pow(coord1[1] - coord2[1], 2))
        }
        
        geocode()
    </script>
  </body>
</html>
